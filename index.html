import React, { useState, useEffect, useRef, useCallback } from 'react';
import { Play, RotateCcw, Trophy, ChevronUp, ChevronDown, ChevronLeft, ChevronRight } from 'lucide-react';

// 游戏配置常量
const GRID_SIZE = 20; // 网格大小
const INITIAL_SPEED = 150; // 初始速度 (毫秒)
const SPEED_INCREMENT = 2; // 每吃一个食物减少的毫秒数
const MIN_SPEED = 60; // 最快速度限制

// 辅助函数：生成随机食物位置，不能在蛇身上
const generateFood = (snakeBody) => {
  let newFood;
  while (true) {
    newFood = {
      x: Math.floor(Math.random() * GRID_SIZE),
      y: Math.floor(Math.random() * GRID_SIZE),
    };
    const isOnSnake = snakeBody.some(segment => segment.x === newFood.x && segment.y === newFood.y);
    if (!isOnSnake) break;
  }
  return newFood;
};

export default function App() {
  // 游戏状态: 'MENU', 'PLAYING', 'GAME_OVER'
  const [gameState, setGameState] = useState('MENU');
  const [score, setScore] = useState(0);
  const [highScore, setHighScore] = useState(0);
  
  // 蛇的状态
  const [snake, setSnake] = useState([{ x: 10, y: 10 }]);
  const [food, setFood] = useState({ x: 5, y: 5 });
  const [direction, setDirection] = useState({ x: 0, y: -1 }); // 初始向上
  
  // 使用 ref 来存储当前实际移动方向，防止在一次 tick 内快速连续按键导致掉头自杀
  const currentDirectionRef = useRef({ x: 0, y: -1 });
  const speedRef = useRef(INITIAL_SPEED);
  const gameLoopRef = useRef(null);

  // 初始化/读取最高分
  useEffect(() => {
    const saved = localStorage.getItem('snakeHighScore');
    if (saved) setHighScore(parseInt(saved, 10));
  }, []);

  // 游戏主循环
  const gameTick = useCallback(() => {
    setSnake(prevSnake => {
      const head = prevSnake[0];
      const newHead = {
        x: head.x + currentDirectionRef.current.x,
        y: head.y + currentDirectionRef.current.y
      };

      // 1. 碰撞检测：撞墙
      if (
        newHead.x < 0 || 
        newHead.x >= GRID_SIZE || 
        newHead.y < 0 || 
        newHead.y >= GRID_SIZE
      ) {
        setGameState('GAME_OVER');
        return prevSnake;
      }

      // 2. 碰撞检测：撞自己
      if (prevSnake.some(segment => segment.x === newHead.x && segment.y === newHead.y)) {
        setGameState('GAME_OVER');
        return prevSnake;
      }

      const newSnake = [newHead, ...prevSnake];

      // 3. 吃食物检测
      if (newHead.x === food.x && newHead.y === food.y) {
        setScore(s => {
          const newScore = s + 10;
          // 增加速度
          speedRef.current = Math.max(MIN_SPEED, speedRef.current - SPEED_INCREMENT);
          return newScore;
        });
        setFood(generateFood(newSnake));
        // 这里不移除尾部，相当于变长
      } else {
        // 没吃到食物，移除尾部，保持长度不变（但因为加了头，实际上是移动）
        newSnake.pop();
      }

      return newSnake;
    });
  }, [food]);

  // 控制游戏循环的启动和停止
  useEffect(() => {
    if (gameState === 'PLAYING') {
      gameLoopRef.current = setInterval(gameTick, speedRef.current);
    } else {
      if (gameLoopRef.current) clearInterval(gameLoopRef.current);
      // 游戏结束更新最高分
      if (gameState === 'GAME_OVER') {
        if (score > highScore) {
          setHighScore(score);
          localStorage.setItem('snakeHighScore', score.toString());
        }
      }
    }
    return () => {
      if (gameLoopRef.current) clearInterval(gameLoopRef.current);
    };
  }, [gameState, gameTick, score, highScore]);

  // 这里的 useEffect 专门用于在速度变化时重置定时器，保证加速平滑
  useEffect(() => {
    if (gameState === 'PLAYING') {
      if (gameLoopRef.current) clearInterval(gameLoopRef.current);
      gameLoopRef.current = setInterval(gameTick, speedRef.current);
    }
  }, [score]); // score 变了说明可能加速了

  // 处理方向改变 (兼容键盘)
  const handleDirectionChange = useCallback((newDir) => {
    // 禁止直接掉头 (比如当前向左，不能按右)
    // 利用 currentDirectionRef 确保判断的是上一帧的真实方向
    const current = currentDirectionRef.current;
    if (newDir.x + current.x === 0 && newDir.y + current.y === 0) return;
    
    // 更新 Ref 供下一次 tick 使用
    currentDirectionRef.current = newDir;
    // 更新 State 仅用于 UI (如果有需要)
    setDirection(newDir);
  }, []);

  // 键盘监听
  useEffect(() => {
    const handleKeyDown = (e) => {
      if (gameState !== 'PLAYING') return;
      
      switch (e.key) {
        case 'ArrowUp': handleDirectionChange({ x: 0, y: -1 }); break;
        case 'ArrowDown': handleDirectionChange({ x: 0, y: 1 }); break;
        case 'ArrowLeft': handleDirectionChange({ x: -1, y: 0 }); break;
        case 'ArrowRight': handleDirectionChange({ x: 1, y: 0 }); break;
        default: break;
      }
    };
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [gameState, handleDirectionChange]);

  // 开始游戏逻辑
  const startGame = () => {
    setSnake([{ x: 10, y: 10 }, { x: 10, y: 11 }, { x: 10, y: 12 }]); // 初始长度为3
    setFood(generateFood([{ x: 10, y: 10 }, { x: 10, y: 11 }, { x: 10, y: 12 }]));
    setScore(0);
    setDirection({ x: 0, y: -1 });
    currentDirectionRef.current = { x: 0, y: -1 };
    speedRef.current = INITIAL_SPEED;
    setGameState('PLAYING');
  };

  return (
    <div className="flex flex-col items-center justify-center min-h-screen bg-gray-900 text-white p-4 font-sans touch-none">
      
      {/* 标题栏 */}
      <div className="w-full max-w-md flex justify-between items-center mb-4 bg-gray-800 p-4 rounded-xl shadow-lg">
        <div>
          <h1 className="text-xl font-bold text-green-400">贪吃蛇</h1>
          <div className="text-xs text-gray-400 flex items-center gap-1">
            <Trophy size={12} /> 最高分: {highScore}
          </div>
        </div>
        <div className="text-2xl font-mono font-bold text-white">
          {score}
        </div>
      </div>

      {/* 游戏画布区域 */}
      <div className="relative bg-black border-4 border-gray-700 rounded-lg shadow-2xl overflow-hidden">
        {/* 游戏网格 */}
        <div 
          style={{ 
            display: 'grid', 
            gridTemplateColumns: `repeat(${GRID_SIZE}, 1fr)`,
            width: 'min(90vw, 400px)',
            height: 'min(90vw, 400px)',
          }}
        >
          {Array.from({ length: GRID_SIZE * GRID_SIZE }).map((_, i) => {
            const x = i % GRID_SIZE;
            const y = Math.floor(i / GRID_SIZE);
            
            const isSnakeHead = snake[0].x === x && snake[0].y === y;
            const isSnakeBody = snake.some((s, index) => index !== 0 && s.x === x && s.y === y);
            const isFood = food.x === x && food.y === y;

            let cellClass = "w-full h-full border border-gray-900/10 ";
            if (isSnakeHead) cellClass += "bg-green-400 rounded-sm z-10";
            else if (isSnakeBody) cellClass += "bg-green-600 rounded-sm";
            else if (isFood) cellClass += "bg-red-500 rounded-full scale-75 shadow-[0_0_10px_rgba(239,68,68,0.8)]";
            else cellClass += "bg-gray-800/30";

            return <div key={i} className={cellClass} />;
          })}
        </div>

        {/* 覆盖层：菜单 */}
        {gameState === 'MENU' && (
          <div className="absolute inset-0 bg-black/80 flex flex-col items-center justify-center z-20 backdrop-blur-sm">
            <h2 className="text-3xl font-bold mb-6 text-green-400 tracking-wider">SNAKE</h2>
            <button 
              onClick={startGame}
              className="flex items-center gap-2 px-8 py-3 bg-green-500 hover:bg-green-600 active:bg-green-700 text-white font-bold rounded-full transition-all transform hover:scale-105 shadow-lg shadow-green-500/30"
            >
              <Play size={20} fill="currentColor" /> 开始游戏
            </button>
            <p className="mt-4 text-gray-400 text-sm">点击按钮开始</p>
          </div>
        )}

        {/* 覆盖层：游戏结束 */}
        {gameState === 'GAME_OVER' && (
          <div className="absolute inset-0 bg-black/80 flex flex-col items-center justify-center z-20 backdrop-blur-sm">
            <h2 className="text-3xl font-bold mb-2 text-red-500">GAME OVER</h2>
            <p className="text-gray-300 mb-6">最终得分: {score}</p>
            <button 
              onClick={startGame}
              className="flex items-center gap-2 px-8 py-3 bg-white text-black hover:bg-gray-200 font-bold rounded-full transition-all transform hover:scale-105"
            >
              <RotateCcw size={20} /> 再玩一次
            </button>
          </div>
        )}
      </div>

      {/* 移动端控制器 */}
      <div className="mt-8 grid grid-cols-3 gap-2 w-48 h-48 select-none touch-manipulation">
        <div className="col-start-2">
          <ControlButton 
            onClick={() => handleDirectionChange({ x: 0, y: -1 })} 
            icon={<ChevronUp size={32} />} 
          />
        </div>
        <div className="col-start-1 row-start-2">
          <ControlButton 
            onClick={() => handleDirectionChange({ x: -1, y: 0 })} 
            icon={<ChevronLeft size={32} />} 
          />
        </div>
        <div className="col-start-2 row-start-2">
          <div className="w-16 h-16 bg-gray-800 rounded-full flex items-center justify-center">
             <div className="w-4 h-4 bg-gray-700 rounded-full"></div>
          </div>
        </div>
        <div className="col-start-3 row-start-2">
          <ControlButton 
            onClick={() => handleDirectionChange({ x: 1, y: 0 })} 
            icon={<ChevronRight size={32} />} 
          />
        </div>
        <div className="col-start-2 row-start-3">
          <ControlButton 
            onClick={() => handleDirectionChange({ x: 0, y: 1 })} 
            icon={<ChevronDown size={32} />} 
          />
        </div>
      </div>
      
      <p className="mt-4 text-xs text-gray-500">电脑端使用方向键，手机点击下方按钮</p>
    </div>
  );
}

// 独立的控制按钮组件，提取出来方便复用样式
function ControlButton({ onClick, icon }) {
  return (
    <button 
      className="w-16 h-16 bg-gray-800 rounded-2xl flex items-center justify-center text-gray-400 hover:bg-gray-700 hover:text-white active:bg-green-600 active:text-white active:scale-95 transition-all shadow-lg border-b-4 border-gray-950 active:border-b-0 active:translate-y-1"
      onPointerDown={(e) => {
        // 使用 PointerDown 获得比 Click 更快的响应，并防止双击缩放
        e.preventDefault();
        onClick();
      }}
    >
      {icon}
    </button>
  );
}
